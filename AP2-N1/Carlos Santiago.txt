1) Para o nosso problema, pensei nas seguintes soluções: - Seleção de Amostras: Usaria a estratégia de Hold-On inicialmente, ou seja, selecionaria alguns exemplos para formar um conjunto de amostras periodicamente e os dividiria em 80/20 para teste e treino. Usaria também Cross-Validation, ou seja: Em cada época no meu processo de treinamento e teste, quando eu pegasse uma nova amostra, eu treinaria o meu modelo criando várias partições do meu conjunto de amostras para ficar variando como conjunto de teste. O cross-validation vai ajudar bastante na ideia de garantir que o sistema fique atualizado, mas não é a única estratégia que irei abordar. Esse processo de seleção deve ser feito periodicamente para garantir que o sistema fique atualizado. Para resolver o problema de atualização, poderíamos colocar um peso (variando de por exemplo 1.0 até 0.0) para cada item presente na amostra coletada. Se o item foi comprado recente, seria inserido com peso 1 de relevância, e com o passar das compras, se caso itens daquela categoria forem mais frequentes, o peso iria continuar com a mesma relevância, caso contrário o peso iria diminuir periodicamente até ele deixar de ser relevante, sendo recomendado o mínimo possível. - Pré-processamento de dados: Como a questão explica, a idade se torna uma variável muito ruidosa para esse problema. A minha estratégia seria reduzir esse ruido com bucketing, ou seja, estabelecer intervalos de idades ((0-20), (21-40), (41-60)…) e agrupar as pessoas com idades nesses intervalos. - Explicação do Uso no Algoritmo: De forma sucinta, eu usaria o KNN para esse sistema de recomendação. Toda vez que um usuário novo entrasse, ele usaria selecionaria a Idade, Tempo de Navegação, Histórico e Categorias Visualizadas. o KNN agiria da seguinte forma: onde ao objeto ser inserido no plano, ele calcularia a distância para todos os vizinhos de cada grupos e escolheria um número x de vizinhos, ele classificaria esse nosso objeto de acordo com a moda do grupo dos vizinhos (se tiverem 5, e houver 3 dentro da faixa de 0-20 que compram Jogos, e 2 dentro da faixa 0-20 que compram Fardo de Chilito, ele irá selecionar a faixa 0-20 dos Jogos). Com isso o sistema iria recomendar para o usuário itens de acordo com a sua faixa de idade, verificando as compras mais frequentes de um mesmo grupo de usuários e recomendando entre eles.
2a) Para projetar esse sistema de recomendação com KNN, a minha ideia é utilizar principalmente o histórico de compras, a idade, e o sexo (e algumas variáveis adjacentes não citadas) para resolver o problema. O meu pré processamento iria focar na parte de conversão dos meus dados nominais para números. Para a conversão de gênero por exemplo, usaria one-hot-enconding (que consistiria em criar várias categorias masculino, feminino, não-binário com 0 ou 1 em cada uma, dependendo do que está no perfil do usuário (se ele colocou masculino, seria por exemplo 100)). Seriam usados principalmente one-hot-encoding e ordem canônica. A estratégia de criação, treinamento e validação seria a clássica hold-on, onde eu selecionaria uma amostra do meu conjunto de dados e dividiria ela em Treino e Teste (80% da amostra para treino, e 20% da amostra para teste), e treinaria o meu modelo com épocas por épocas até ter uma boa efetividade. Para validação, usaria também o cross-validation: em cada época no meu processo de treinamento e teste, quando eu pegasse uma nova amostra, eu treinaria o meu modelo criando várias partições do meu conjunto de amostras para ficar variando como conjunto de teste, permitindo que nenhuma amostra fosse perdida por estar no conjunto de teste. Para uso, poderíamos ter uma classe chamada Pessoa, e nela teria uma função chamada recomendaItem(), retornaria um String contendo o nome do item. Ao chamar essa função, ela realizaria o algoritmo do KNN, onde pegaria cada vetor contendo os itens da amostras que já estão em grupos e faria o cálculo da distância. Faríamos um dicionário que iria conter de chave a distância e o valor seria o grupo. Ordenaríamos o vetor pela chave, e fariámos um contador para as quantidades (poderia ser dentro de um vetor para ser flexível com os grupos) e retornaríamos o valor mais frequente entre os itens, que seria no caso na estrutura do dicionário, seria uma string contendo o nome do item.
2b) Podemos utilizar o CBR para este mesmo problema. Qual a ideia? Criaríamos um banco de dados contendo os casos, onde guardaríamos nele tentativas de recomendação (que deram certo e que deram errado) baseadas novamente em grupos. Projeção de Sistema - Seleção de Amostras e Pré-processamento: As amostras coletadas como são para o mesmo problema, seriam informações dos usuário (idade, histórico de compras, sexo..). O pré processamento também seria o mesmo, focando nas características nominais e utilizando técnicas como one-hot-enconding, label encoding, ordinal encoding…) - Treinamento e Validação: Usaria o hold-on e cross validation, como já expliquei posteriormente a utilização de cada um. - CBR: Usariamos o CBR para tentar recomendar itens, e caso sejam ignorados ou clicados, são registrados no banco de dados. Com uma base boa de casos no CBR, o sistema puxaria os dados do banco (retrieve) que recomendações que ele já testou entre itens do grupo, testaria uma das soluções que ele já tem (reuse). Dependendo da escolha do usuário (por exemplo, se ele comprou o item ou não), ele revisaria e diria se a recomendação deu certo ou não e após isso iria reter o caso dentro do
banco de dados.
